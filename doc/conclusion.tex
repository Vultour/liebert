\section{Conclusions}
    \subsection{Discussion and Summary}
        In conclusion, the project fulfilled its primary objective to be a learning experience. Over the past few months it provided countless opportunities for expanding both theoretical and practical knowledge, be it in the form of learning the new programming language \textit{Rust}, or trying to figure out the intricacies of threads. During this time it also sparked numerous productive technical discussions with my peers, as well as online.
        
        Even though it is unfortunate that the goal of creating an efficient and fast monitoring solution has been unsuccessful, I believe that the groundwork has been laid. Should the development of the application continue, it is very possible that only a couple of changes could have tremendous effect on the overall efficiency of the application processor-wise. If the time to switch away from the multi-threaded model could be found (read more in the next section), it would very likely put the application on the forefront of efficiency in terms of memory.
        
        I can say in good faith that maximum effort has been put into optimizing the application wherever possible. In retrospect, this might not have been the best course of action, as a single large decision like the multi-threaded model managed to wipe out the endless stream of micro-optimizations undertaken during development. Even through all of this however, remnants of the optimizations still manage to shine through once in a while, such as was the case with performance of the \textit{Controller}. It is therefore pretty clear that most of the inefficiencies stem from inexperience and not willful ignorance of the requirements.


        \clearpage
    

\section{Possible Future Work and Enhancements}\label{sec:future-work}
    \subsection{Event model}
        A large portion of the application's inefficiencies (especially in memory consumption) comes from the threading model. Once these were discovered, an alternative model has been produced, unfortunately re-developing the application from the start was out of scope of the project. The new model uses a single main thread, and a configurable amount of \textit{worker} threads. The main thread acts as an event loop, continuously checking which plugins should be ran, and sending a message notifying one of the \textit{worker} threads to execute the plugin code once it's supposed to be scheduled. This would reduce the amount of required threads to a minimum of 4: main, worker, network reader, and network writer. There is no way of reducing the network thread requirement due to \textit{Rust}'s synchronous I/O.
        
        The synchronousness of \textit{Rust}'s I/O is unfortunately a bigger problem in the \textit{Controller} application, as it must spawn a new thread for each connected \textit{Agent}. This means that even though we could reduce the load imposed by unnecessary plugin thread spawning, we would still have potentially hundreds or thousands of threads being spawned for network communication purposes. Although their load might not be as significant, considering that their underlying code would be very similar, therefore they could utilize shared memory. It is still however an extreme overkill, be it from memory utilization, or the incredible amount of context switching required for such load. A more sensible solution would be to rewrite the \textit{Controller} application in a more network-friendly language. My personal favourite is Elixir\footnote{Basically an upgraded version of Erlang}, as it has something called \textit{processes}\footnote{Not to be confused with operating system processes}. \textit{Processes} are extremely lightweight (compared to OS processes or threads), isolated from one another, and run in parallel. A typical \textit{Elixir} application is able to handle thousands, or even tens of thousands, of processes with ease. This would unfortunately not fall in line with the project's vision, as it requires the installation of the Elixir / Erlang VM. \textsc{Liebert}, being written in \textit{Rust}, can be easily distributed in binary form and doesn't have any dependencies. Additionally, \textit{Rust} is built with cross-platform compatibility in mind, unlike many other languages (primary targets are Linux, Windows, and OSX).
        
    \subsection{Plugins}
        Regrettably, the plugin system has not been finished, therefore only core built-in gatherers and storage backends are currently available. Much of the infrastructure for plugin support has been put in place however, such as the custom format specifiers that can be reported and consumed by plugins. The actual plugin functionality is however not present in the current version of the project, as although it might look like a fairly simple task, it would probably require a lot of tinkering to get right. It has therefore been decided to leave this feature out in favour of other essential core features.
        
    \subsection{Code refactoring}
        As has previously been mentioned in multiple chapters, the code is currently nowhere near perfect. Often, tasks and problems were dealt with using semi-temporary workarounds or hacks due to time constraints. Furthermore, it would be very beneficial to split larger code blocks into separate functions to assist in testing. Refactoring the code to fix these issues would increase the overall quality and understandability, potentially allowing other people to collaborate on extending the project.